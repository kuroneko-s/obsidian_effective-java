equals는 재정의하지 않는게 가장 좋은 방법이다.
재정의하지 않아도 되는 상황과 재정의 해야만하는 상황이 존재한다.

### 재정의하지 않아도 되는 상황
1. 인스턴스의 본질이 고유하다.
- 싱글톤은 인스턴스가 단 하나이니깐 비교할 일이 없음. 특정 값을 가지고 의미를 지닌 객체가 아닌, 특정 동작을 표현하고 있는 객체. (Thread)
> Thread는 값을 가지는게 아니라 run 메서드에 특정 동작을 넣어서 동작시키는 객체.
2. 논리적 동치성을 검사하지 않아도 된다.
- String의 equals. 문자열에서 각 문자열 객체가 고유한 값인지 비교하진 않음. 그저 그 안에 무슨 문자열의 값을 가지고 있는가가 중요함.  
3. 상위 클래스에 이미 재정의가 되어있다.
- Collections 객체들의 AbstractOOO 들의 경우 이미 euqals가 정의되어 있음. 그래서 하위 클래스인 List, Set, Map 등은 재정의하지 않아도 동작에 문제가 없음.
4. private, package-private의 클래스이면서, equals를 호출할 일이 없다.
- 의도적으로 사용되는 범위를 지정하고 어떤 메서드들을 사용할건지를 설계단위에서 정해놓은 경우 굳이 재정의를 하지 않아도 됨. 단지 호출이 되는 것을 막고 싶을때 Exception 발생시켜주는 경우는 존재함
> public 객체의 경우 호출 되지 않음을 보장받읊 수 없으므로 해당 사항에 적용되지 않음.

결국에는 객체가 public하게 여러개가 존재하는 상황에서 내부의 파라미터가 각각 다를 수 있는 객체인 경우가 아니면 재정의 안하는게 낫다는 거 ? 
### 재정의 해야만하는 상황
객체 식별성(identity)이 아니라 논리적 동치성(내부의 값 등)을 확인해야 하는데, 상위 클래스의 euqals가 논리적 동치성을 비교하도록 재정의되지 않았을 경우.
대부분의 값 클래스(Integer, String etc...)가 여기에 해당된다. 
값 클래스에서도 싱글톤이 보장이 된다면 재정의하지 않아도 된다. (재정의 하지 않아도 되는 조건이 우선적으로 적용됨.)
#### 재정의시 반드시 지켜야하는 일반 규약.
기본적으로 Object의 equals 메서드에 주석으로 해당내용이 기재되어있다.
1. 반사성(reflexivity)
	null이 아닌 모든 참조 값 x에 대해, x.equals(x) == true
2. 대칭성(symmetry)
	null이 아닌 모든 참조 값 x, y에 대해, x.equals(y) == true && y.equals(x) == true
3. 추이성(transitivity)
	null이 아닌 모든 참조 값 x, y, z에 대해, x.equals(y) == true && y.equals(z) == true && x.equals(z) == true
4. 일관성(consistency)
	null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)를 반복해서 호출하면 항상 같은 값이 반환되어야 한다.
5. not-null
	null이 아닌 모든 참조 값 x에 대해, x.equals(null) == false
> 되게 당연한 결과들.

상속받고 필드를 추가한 클래스의 경우 equals의 규약을 지킬 수가 없다.
상속을 대체하는 방법으로 컴포지션을 사용해서 상속과 비슷하게 동작 시키게끔 구현하는 방법을 추천한다.
컴포지션으로 추가한 후 해당 타입에 대한 view 메서드를 추가해준다.
추상 클래스를 상속받은 경우에는 정상적으로 구현할 수 있다. 어디까지나 상위 클래스를 인스턴스로 만들 수 있을 경우에만 발생하는 문제이다.

일관성의 경우에는 신뢰할 수 없는 자원이 equals의 비교 대상이 되어선 안된다. 
예시로 java의 URL.equals. 해당 메서드는 IP로  비교한다. 자신이 어디에서 인터넷을 사용하고 있느냐에 따라서 결과가 달라진다는 소리.
이런 문제를 피하기 위해선 메모리에 존재하는 객체만을 사용해서 결정적(deterministic - 미래 상태 개발에 임의성이 포함되지 않는 시스템) 계산만 수행해야 한다.

null 검사는 명시적으로 해도되고 안해도 됨. 
instanceof 에서 null이면 false를 반환함.