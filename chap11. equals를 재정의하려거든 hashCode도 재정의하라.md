equals를 재정의하는 클래스라면 값으로써 사용되는 경우일 것이다. 핵심 값 (필드)이 그 클래스의 역할을 다 할 텐데, 이 값들이 같다면 같은 객체로써 취급해야 한다. 그런데 같은 클래스임에도 같은 hashcode를 반환하게 된다면 어떻게 될까 ?

Hash 알고리즘을 이용하는 Collections들을 예로 들어보자.

HashMap에서 값 클래스를 equals만 재정의를 한 채로 추가를 하게된다면, 인스턴스를 새롭게 생성을 한 객체들이라고 하더라도 각 클래스의 의미는 같을 것이다. 하지만 HashMap에서 해당 인스턴스에 대해 인식할 때에는 HashCode값을 기준으로 저장을 하게 될 것이며, 그렇게 될 경우 서로 다른 HashCode를 반환을 한 같은 의미를 가진 값 클래스도 각각 다르게 저장이 될 것이다. 그렇게 된다면, 저장한 값들을 다른곳에서 새로운 인스턴스를 사용하여 찾을려고 할 때 찾지 못할 것이다.(null 반환)

### 재정의 시 규약.
- equals에 사용된 필드들은 hashCode에서도 모두 사용해야한다.
- __equals에서 같은 객체라고 판단했다면 hashCode도 같아야한다.
- equals가 서로 다른 객체가 hashCode가 같아도 된다. (같으면 해시 테이블 성능이 떨어지긴 한다.)

서로 같은 해시값을 가진 서로 다른 객체들은 HashMap의 버켓의 내부에 LinkedList로 저장이 된다.
그리고 해당 리스트의 길이가 8이상? 7이상? 이면 트리구조 (블랙-레드 트리)로 변환되서 동작한다.
(java8에서 HashMap 동작이 바뀐다는게 이 소리.)

### hashCode 작성하는 요령.
완벽하게 따를 필요는 없지만 일단 알아두면 괜찮은 듯
equals에서 사용한 필드를 순서대로 진행할 것.
1. 먼저 타입에서 hashCode 값을 만듬 (a)
2. 31(소수 값) + 1에서 만든 값 + 1에서 진행한 것과 같이 다음 필드의 hashCode 값.

AutoValue로 생성했으면 건너 띄워도 됨.
이와 동시에 lombock을 사용했을때도 어차피 둘다 생성할 수 있는 애노테이션을 사용하게 되고 IDE를 이용해서 만들어도 거의 세트로 만들어서 사용함.
IDE를 이용해서 재정의할 경우 Objects.hash로 만들어버림.

이런방법을 사용하기 싫고 충독이 더욱 적은 방법을 사용하고 싶다면 구아바의 com.google.common.hash.Hashing을 사용하면 됨.(굳이 ?)

지연 초기화(lazy initialization) 사용해도 됨.
클래스가 불변이고 해시코드 계산하는 비용이 크다면 캐싱으로 사용하는 방법을 고려해도 된다.
이때는 Thread Safety하게 설계 해야함.

그 어떤 상황에서도 equals에서 사용한 필드를 hashCode에서 사용을 안하면 안됨.
무조건 같은 필드들을 사용해야함.
사용을 안하면 해시 값의 품질이 이상해져서 해시를 이용한 전반적인 알고리즘에 악영향을 준다.
