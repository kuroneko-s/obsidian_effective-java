equals를 재정의하는 클래스라면 값으로써 사용되는 경우일 것이다. 핵심 값 (필드)이 그 클래스의 역할을 다 할 텐데, 이 값들이 같다면 같은 객체로써 취급해야 한다. 그런데 같은 클래스임에도 같은 hashcode를 반환하게 된다면 어떻게 될까 ?

Hash 알고리즘을 이용하는 Collections들을 예로 들어보자.

HashMap에서 값 클래스를 equals만 재정의를 한 채로 추가를 하게된다면, 인스턴스를 새롭게 생성을 한 객체들이라고 하더라도 각 클래스의 의미는 같을 것이다. 하지만 HashMap에서 해당 인스턴스에 대해 인식할 때에는 HashCode값을 기준으로 저장을 하게 될 것이며, 그렇게 될 경우 서로 다른 HashCode를 반환을 한 같은 의미를 가진 값 클래스도 각각 다르게 저장이 될 것이다. 그렇게 된다면, 저장한 값들을 다른곳에서 새로운 인스턴스를 사용하여 찾을려고 할 때 찾지 못할 것이다.(null 반환)

### 재정의 시 규약.
- equals에 사용된 필드들은 hashCode에서도 모두 사용해야한다.
- __equals에서 같은 객체라고 판단했다면 hashCode도 같아야한다.
- equals가 서로 다른 객체가 hashCode가 같아도 된다. (같으면 해시 테이블 성능이 떨어지긴 한다.)

서로 같은 해시값을 가진 서로 다른 객체들은 HashMap의 버켓의 내부에 LinkedList로 저장이 된다.
그리고 해당 리스트의 길이가 8이상? 7이상? 이면 트리구조 (블랙-레드 트리)로 변환되서 동작한다.
(java8에서 HashMap 동작이 바뀐다는게 이 소리.)
