protected Obeject clone.
오버라이딩시 접근제어자를 public으로 변경, 리턴값은 구현하는 객체로 변경해야함.
Cloneable을 구현하고 있지 않으면 Exception 발생.

#### 기본규약
1. x.clone() != x
2. x.clone().getClass() == x.getClass()
3. x.clone.equals(x) // true || false 둘다 나옴.

규약이 너무 허술함.
이 규약의 3번이 강제성이 없음.

내부에서 호출시 super.clone으로 구현하지 않고 생성자를 사용할시 규약의 2번이 깨짐.
super.clone을 미사용함으로써 생기는 문제는 하위 클래스가 존재할 경우이므로 클래스가 불변 클래스인 경우 해당 이유로 인해 문제가 발생하진 않음.

가변 클래스가 가변 객체를 참조하고 있다면 훨씬 까다로워진다.
super.clone으로 값을 복제한다면 객체도 같은 객체를 바라보게 되니깐 심각하게 문제가 생긴다.
clone 메서드는 사실상 생성자와 같은 효과를 냄. 즉, clone은 원본 객체에 그 어떠한 해를 끼치면 안됨.
이런 문제를 없얠려면 상위의 객체나 메서드를 이용해서 별도로 생성을 해주거나 deep copy를 이용해야하는 번거로움이  있다.

deep copy시 재귀로 실행하면 스택 오버 플로우 에러도 발생할 수 있으니 조심해야 한다.

clone 메서드 사용시 가별 객체를 참조하는 필드에 final을 사용할 수 없음.
복사를 해야하는데 새롭게 값을 못넣거든.
그러면 같은 객체를 참조하고있는 값을 넣어지게 되고 이러면 많이 심각해져서 final을 제거해야함.
clone을 사용하기 위해서 final로 사용해야하는 필드를 사용안하면 너무 위험해짐.

아니면 고수준의 메서드들을 사용해서 복사하는 방법이 있는데 이러면 저수준보다는 조금 느리긴 함.

그리고 생성자에서는 재정의 될 수 있는 메서드를 호출하지 않아야 하는데 clone도 동일함.
(새로운 객체를 만들어주는 것이라는 틀은 비슷하게 동작하니깐)

재정의할 수 있는 메서드를 clone 내에서 사용해선 안된다 => 하위 클래스에서 메서드를 재정의 할 경우 값이 유지됨을 보장받지 못하니깐. 랜덤하게 바뀌니깐 서로 다른 객체의 동치성을 비교하면 false가 나서 같은 객체라고 말할 수 없게 됨.

Object의 clone메서드에서 throw를 던지고있는 CloneNotSupportedException을 재정의해서 throws를 없애야 함. (다른 에러는 상관 없음.)

이게 원랜 NonCheckedException으로 적용해야 논리상 맞는건데 CheckedExcepiton으로 만들어놔서 생기는 번거로운 문제임...

thread safety한 환경에서는 clone도 같이 동기화를
